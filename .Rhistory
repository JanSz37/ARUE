library(sf)
library(sf)
library(jsonlite)
library(dplyr)
library(ggplot2)
library(tmap)
warsaw_districts <- st_read("dzielnice_Warszawy.shp")
tbus_data <- fromJSON("bus_tram_stops.customization")
metro_data <- fromJSON("metro_stops.customization")
View(metro_data)
properties <- read_csv('apartments_pl_2024_06.csv')
properties <- read.csv('apartments_pl_2024_06.csv')
View(properties)
str(warsaw_districts)
str(tbus_data)
str(metro_data)
str(properties)
?str()
str(tbus_data)
str(properties)
tbus_coords <- tbus_data$result %>%
mutate(latitude = as.numeric(szer_geo), longitude = as.numeric(dlug_geo)) %>%
select(latitude, longitude)
str(tbus_data)
library(tidyr)
tbus_values <- tbus_data$result$values
extract_row <- function(row) {
row %>%
pivot_wider(names_from = key, values_from = value)
}
tbus_clean <- tbus_values %>%
lapply(extract_row) %>%
bind_rows()
View(tbus_clean)
#metro
metro_values <- metro_data$result$values
str(metro_data)
feature_list <- metro_data$result$featureMemberList
# Extract latitude and longitude
coordinates <- feature_list$geometry$coordinates %>%
bind_rows() %>%
rename(latitude = latitude, longitude = longitude)
# Extract properties (e.g., OBJECTID)
properties <- feature_list$properties %>%
bind_rows() %>%
rename(OBJECTID = value)
# Combine the data
metro_df <- cbind(coordinates, properties)
View(metro_df)
str(tbus_clean)
str(metro_df)
str(properties)
tbus_clean <- tbus_clean %>%
mutate(szer_geo = as.numeric(szer_geo),
dlug_geo = as.numeric(dlug_geo))
metro_df <- metro_df %>%
mutate(latitude = as.numeric(latitude),
longitude = as.numeric(longitude))
# Combine tram/bus and metro data into one public transport dataset
public_transport <- bind_rows(
tbus_clean %>% select(latitude = szer_geo, longitude = dlug_geo),
metro_df %>% select(latitude, longitude)
)
View(public_transport)
metro_df <- metro_df %>%
mutate(transport_type = "M")
tbus_clean <- tbus_clean %>%
mutate(transport_type = "T/B")
tbus_clean <- tbus_clean %>%
mutate(szer_geo = as.numeric(szer_geo),
dlug_geo = as.numeric(dlug_geo))
metro_df <- metro_df %>%
mutate(latitude = as.numeric(latitude),
longitude = as.numeric(longitude))
# Combine tram/bus and metro data into one public transport dataset - idk if thats the right approach
public_transport <- bind_rows(
tbus_clean %>% select(latitude = szer_geo, longitude = dlug_geo),
metro_df %>% select(latitude, longitude)
)
# Combine tram/bus and metro data into one public transport dataset - idk if thats the right approach
public_transport <- bind_rows(
tbus_clean %>% select(latitude = szer_geo, longitude = dlug_geo, transport_type),
metro_df %>% select(latitude, longitude, transport_type)
)
View(public_transport)
View(properties)
properties <- read.csv('apartments_pl_2024_06.csv') #for now i load one month. If we have too little data, we can load more months and delete duplicate offers.
properties1 <- read.csv('apartments_pl_2024_06.csv') #for now i load one month. If we have too little data, we can load more months and delete duplicate offers.
properties_warsaw <- properties %>%
filter(city == "warszawa")
properties_warsaw <- properties1 %>%
filter(city == "warszawa")
View(properties_warsaw)
# Function to calculate the minimum distance and transport type
calculate_min_distance_and_type <- function(prop_lat, prop_lon, transport_df) {
distances <- distHaversine(
c(prop_lon, prop_lat),
transport_df %>% select(longitude, latitude)
)
min_index <- which.min(distances) # Index of the nearest transport location
list(
min_distance = min(distances), # Minimum distance
transport_type = transport_df$transport_type[min_index] # Type of nearest transport
)
}
# Function to calculate the minimum distance and transport type
calculate_min_distance_and_type <- function(prop_lat, prop_lon, transport_df) {
distances <- distHaversine(
c(prop_lon, prop_lat),
transport_df %>% select(longitude, latitude)
)
min_index <- which.min(distances) # Index of the nearest transport location
list(
min_distance = min(distances), # Minimum distance
transport_type = transport_df$transport_type[min_index] # Type of nearest transport
)
}
properties_warsaw <- properties_warsaw %>%
rowwise() %>%
mutate(
min_distance = calculate_min_distance_and_type(latitude, longitude, public_transport)$min_distance,
nearest_transport_type = calculate_min_distance_and_type(latitude, longitude, public_transport)$transport_type
) %>%
ungroup()
install.packages('geosphere')
# Function to calculate the minimum distance and transport type
library(geosphere)
calculate_min_distance_and_type <- function(prop_lat, prop_lon, transport_df) {
distances <- distHaversine(
c(prop_lon, prop_lat),
transport_df %>% select(longitude, latitude)
)
min_index <- which.min(distances) # Index of the nearest transport location
list(
min_distance = min(distances), # Minimum distance
transport_type = transport_df$transport_type[min_index] # Type of nearest transport
)
}
properties_warsaw <- properties_warsaw %>%
rowwise() %>%
mutate(
min_distance = calculate_min_distance_and_type(latitude, longitude, public_transport)$min_distance,
nearest_transport_type = calculate_min_distance_and_type(latitude, longitude, public_transport)$transport_type
) %>%
ungroup()
View(properties_warsaw)
View(properties_warsaw)
ggplot(properties, aes(x = min_distance, y = price/squareMeters)) +
geom_point(alpha = 0.5) +
labs(title = "Property Prices vs. Distance to Public Transport",
x = "Distance to Nearest Public Transport (meters)",
y = "Property Price") +
theme_minimal()
ggplot(properties_warsaw, aes(x = min_distance, y = price/squareMeters)) +
geom_point(alpha = 0.5) +
labs(title = "Property Prices vs. Distance to Public Transport",
x = "Distance to Nearest Public Transport (meters)",
y = "Property Price") +
theme_minimal()
correlation <- cor(properties$min_distance, properties$price, method = "pearson")
str(properties_warsaw)
correlation <- cor(properties_warsaw$min_distance, as.numeric(properties_warsaw$price)/properties_warsaw$squareMeters, method = "pearson")
print(paste("Correlation between distance and price:", correlation))
model <- lm(price/squareMeters ~ min_distance, data = properties_warsaw)
summary(model)
